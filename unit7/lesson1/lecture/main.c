/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


typedef volatile unsigned int vuint32_t ;
#include  <stdint.h>
#include  <stdlib.h>
#include  <stdio.h>

//register address
//RCC
#define RCC_BASE		0x40021000
#define RCC_APB2NER		*(volatile uint32_t*)(RCC_BASE + 0x18)
#define RCC_IOPAEN		(1<<2)

//GPIO
//PORTA
#define GPIOA_BASE		0X40010800
#define GPIOA_CRL		*(volatile uint32_t*)(GPIOA_BASE + 0x00)
#define GPIOA_CRH		*(volatile uint32_t*)(GPIOA_BASE + 0x04)
#define GPIOA_IDR		*(volatile uint32_t*)(GPIOA_BASE + 0x08)
#define GPIOA_ODR		*(volatile uint32_t*)(GPIOA_BASE + 0x0C)

//PORTB
#define GPIOB_BASE		0x4001 0C00
#define GPIOB_CRL		*(volatile uint32_t*)(GPIOA_BASE + 0x00)
#define GPIOB_CRH		*(volatile uint32_t*)(GPIOA_BASE + 0x04)
#define GPIOB_IDR		*(volatile uint32_t*)(GPIOA_BASE + 0x08h)
#define GPIOB_ODR		*(volatile uint32_t*)(GPIOA_BASE + 0x0C)


void clock_init()
{
	// Enable clocK GPIOA
	RCC_APB2NER |= RCC_IOPAEN;

	// Enable clocK GPIOB  Bit 3 IOPAEN : IO PORTB clock enable
	RCC_APB2NER |= (1<<3);

}

void GPIO_init()
{
	//take care CNF by default 1 (check the reset value)
	GPIOA_CRL = 0;
	GPIOA_CRH = 0;
	GPIOA_ODR = 0;

	// 00: input mode : (reset state)
	GPIOA_CRL &= ~ (0b11 << 4);
	//CNF 01 : Floating input (reset state)
	//GPIOA_CRL = 0b10000000;
	GPIOA_CRL |=  (0b01 << 6);

	//PB1(output PUSH pull mode)
	//01: Output mode; max speed 10 MHZ
	GPIOB_CRL |= (0b01 << 4);
	//CNF 00: General Purpose Output Push-Pull
	GPIOB_CRL &= (0b11 << 6);

	// 00: input mode : (reset state)
	GPIOA_CRH &= ~ (0b11 << 20);
	//CNF 01 : Floating input (reset state)
	//GPIOA_CRH = 0b10000000;
	GPIOA_CRH |=  (0b01 << 22);

	//PB1(output PUSH pull mode)
	//01: Output mode; max speed 10 MHZ
	GPIOB_CRH |= (0b01 << 20);
	//CNF 00: General Purpose Output Push-Pull
	GPIOB_CRH &= (0b11 << 22);


}

void wait_ms(uint32_t time){
	uint32_t i , j ;
	for (i = 0 ; i < time ; i++)
		for (j = 0 ; j < 255 ; j++);


}

int main(void)
{
	clock_init();
	GPIO_init();

	while(1)
	{
		if (((GPIOA_IDR & (1<<1))>>1) ==0)
		{
			GPIOB_ODR ^= 1<<1 ;
			while((((GPIOA_IDR & (1<<1))>>1) ==0)); //single pressing
		}
		if ((((GPIOA_IDR & (1<<13)) >> 13) ==1)) //Multi pressing
		{
			GPIOB_ODR ^= 1<<13 ;
		}
		wait_ms(1);
	}
}
